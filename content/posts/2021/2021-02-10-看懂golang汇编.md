---
title: 看懂golang汇编
author: admin
type: post
date: 2021-02-10T07:46:25+00:00
draft: true
private: true
url: /archives/22339
categories:
 - 程序开发
tags:
 - golang

---
Golang 汇编语言并不是一个独立的语言，底层需要依赖Go语言甚至操作系统，有别于我们日常说的独立的汇编开发语言；很多高级特性很难通过手工汇编完成。能看懂汇编代码对理解Golang 内部执行机制是非常有帮助的，所以我们这里简单介绍一下它的一些基本语法。

# X86-64体系结构 

在使用汇编语言之前必须要了解对应的CPU体系结构。下面是X86/AMD架构图：![ch3-2-arch-amd64-01.ditaa](https://blogstatic.haohtml.com/uploads/2021/02/dfe71f867bbafaa455ec677b42558d69-29.png)AMD64架构

整体由三大部分组合，分别为`Memory`、`Register`(寄存器）和 `Instructions`(指令集)。

## 内存布局 

内存布局根据用途分为几个不同的段。

`text`: 只读代码段，主要用于存储要执行的指令数据。
`rodata`/`data`: 数据段，主要用于存放全局数据，其中rodata为只读段。
`heap`: 堆段，主要用于管理动态数据，如有些内存申请指令。
`unused`: 未使用的段。
`stack`: 栈(堆栈)段。主要用于管理函数调用时相关数据，如参数，返回值等。

在汇编语言中一般重点关注`text`代码段和`data`数据段，因此Go汇编语言中专门提供了对应 `TEXT` 和 `DATA` 命令用于定义代码和数据。

## Register寄存器 

寄存器是最为重要的资源，每个要处理的**内存数据**都要先存放到寄存器中才能由CPU来处理，然后再将寄存器中处理完的结果存放到左侧 `Memory` 中。

X86中除了`状态寄存器FLAGS` 和 `指令寄存器IP` 两个特殊的寄存器外，还有AX、BX、CX、DX、SI、DI、BP、SP几个通用寄存器。

在通用寄存器中`BP`和`SP`是两个比较特殊的寄存器：其中`BP`用于记录当前函数帧的开始位置，和函数调用相关的指令会隐式地影响BP的值；`SP`则对应当前栈指针的位置，和栈相关的指令会隐式地影响SP的值；而某些调试工具需要BP寄存器才能正常工作。

在X86-64中又增加了八个以R8-R15方式命名的通用寄存器。

## Instructions 指令集 

CPU是由`指令`和`寄存器`组成，指令是每个CPU内置的算法，指令处理的对象就是全部的寄存器和内存。我们可以将每个指令看作是CPU内置标准库中提供的一个个函数，然后基于这些函数构造更复杂的程序的过程就是用汇编语言编程的过程。

# Go汇编伪寄存器 

我们上面说过Go 汇编与我们同时说的汇编是有所差别的，它在汇编语言的基础上进行了一些简化，引入了`PC`、`FP`、`SP`、`SB`四个伪寄存器。四个伪寄存器加其它的通用寄存器就是Go汇编语言对CPU的重新抽象，该抽象的结构也适用于其它非X86类型的体系结构。![ch3-3-arch-amd64-02.ditaa](https://blogstatic.haohtml.com/uploads/2021/02/7ff5eb752733f96a58687e8ab789f184-38.png)四个伪寄存器和X86/AMD64的内存和寄存器的相互关系（X86-64体系结构）

在AMD64环境，伪`PC寄存器`其实是`IP指令计数器寄存器`的别名。

`伪FP寄存器`对应的是函数的`帧指针`(Frame Pointer)，一般用来访问函数的**参数**和**返回值**；
`伪SP栈指针`对应的是当前函数栈帧的底部（不包括参数和返回值部分），一般用于定位局部变量。

伪SP是一个比较特殊的寄存器，因为还存在一个同名的`SP真寄存器`。真SP寄存器对应的是栈的**顶部**，一般用于定位调用其它函数的参数和返回值。

当需要区分`伪寄存器`和`真寄存器`的时候只需要记住一点：伪寄存器一般需要一个**标识符和偏移量为前缀**，如果没有标识符前缀则是真寄存器。比如`(SP)`、`+8(SP)`没有标识符前缀为`真SP寄存器`，而`a(SP)`、`b+8(SP)`有标识符为前缀表示`伪寄存器`。

# X86-64指令集 

我们以前说汇编语言是不可移植的，其实主要是由于CPU不同，操作系统环境不同等原因导致的，但对于同一种CPU下它的汇编机器指令是完全一样的。

而源自Plan9的Go汇编语言对此做了一定的改进：首先Go汇编语言在相同CPU架构上是完全一致的，也就是屏蔽了操作系统的差异；同时Go汇编语言将一些基础并且类似的指令抽象为相同名字的伪指令，从而减少不同CPU架构下汇编代码的差异（寄存器名字和数量的差异是一直存在的）。

通用的基础机器指令大概可以分为`数据传输指令`、`算术运算`和`逻辑运算指令`、`控制流指令`和`其它指令`等几类。因此我们可以尝试精简出一个X86-64指令集，以便于Go汇编语言的学习。

## 传输指令 

我们先看看重要的MOV指令。其中MOV指令可以用于将字面值移动到寄存器、字面值移到内存、寄存器之间的数据传输、寄存器和内存之间的数据传输。需要注意的是，MOV传输指令的内存操作数只能有一个，可以通过某个临时寄存器达到类似目的。最简单的是忽略符号位的数据传输操作，386和AMD64指令一样，不同的1、2、4和8字节宽度有不同的指令：

| Data Type | 386/AMD64 | Comment |
| --------- | --------- | ------------- |
| [1]byte | MOVB | B => Byte |
| [2]byte | MOVW | W => Word |
| [4]byte | MOVL | L => Long |
| [8]byte | MOVQ | Q => Quadword |386和AMD64指令对比

MOV指令它不仅仅用于在寄存器和内存之间传输数据，而且还可以用于处理数据的扩展和截断操作。当数据宽度和寄存器的宽度不同又需要处理符号位时，386和AMD64有各自不同的指令：

| Data Type | 386 | AMD64 | Comment |
| --------- | ------- | ------- | ----------- |
| int8 | MOVBLSX | MOVBQSX | sign extend |
| uint8 | MOVBLZX | MOVBQZX | zero extend |
| int16 | MOVWLSX | MOVWQSX | sign extend |
| uint16 | MOVWLZX | MOVWQZX | zero extend |386和AMD64指令对比

比如当需要将一个int64类型的数据转为bool类型时，则需要使用MOVBQZX指令处理。

## 算术运算指令 

基础算术指令有ADD、SUB、MUL、DIV等指令。其中ADD、SUB、MUL、DIV用于加、减、乘、除运算，最终结果存入目标寄存器。基础的逻辑运算指令有AND、OR和NOT等几个指令，对应逻辑与、或和取反等几个指令。

| 名称 | 解释 |
| --- | ---- |
| ADD | 加法 |
| SUB | 减法 |
| MUL | 乘法 |
| DIV | 除法 |
| AND | 逻辑与 |
| OR | 逻辑或 |
| NOT | 逻辑取反 |

其中算术和逻辑指令是顺序编程的基础。通过逻辑比较影响状态寄存器，再结合有条件跳转指令就可以实现更复杂的分支或循环结构。需要注意的是MUL和DIV等乘除法指令可能隐含使用了某些寄存器，指令细节请查阅相关手册。

## 控制流指令 

控制流指令有CMP、JMP-if-x、JMP、CALL、RET等指令。CMP指令用于两个操作数做减法，根据比较结果设置状态寄存器的符号位和零位，可以用于有条件跳转的跳转条件。JMP-if-x是一组有条件跳转指令，常用的有JL、JLZ、JE、JNE、JG、JGE等指令，对应小于、小于等于、等于、不等于、大于和大于等于等条件时跳转。JMP指令则对应无条件跳转，将要跳转的地址设置到IP指令寄存器就实现了跳转。而CALL和RET指令分别为调用函数和函数返回指令。

| 名称 | 解释 |
| -------- | -------------------------- |
| JMP | 无条件跳转 |
| JMP-if-x | 有条件跳转，JL、JLZ、JE、JNE、JG、JGE |
| CALL | 调用函数 |
| RET | 函数返回 |

无条件和有条件调整指令是实现分支和循环控制流的基础指令。理论上，我们也可以通过跳转指令实现函数的调用和返回功能。不过因为目前函数已经是现代计算机中的一个最基础的抽象，因此大部分的CPU都针对函数的调用和返回提供了专有的指令和寄存器。

## 其它指令 

其它比较重要的指令有LEA、PUSH、POP等几个。其中LEA指令将标准参数格式中的内存地址加载到寄存器（而不是加载内存位置的内容）。PUSH和POP分别是压栈和出栈指令，通用寄存器中的SP为栈指针，栈是向低地址方向增长的。

| 名称 | 解释 |
| ---- | --- |
| LEA | 取地址 |
| PUSH | 压栈 |
| POP | 出栈 |

当需要通过间接索引的方式访问数组或结构体等某些成员对应的内存时，可以用LEA指令先对目前内存取地址，然后在操作对应内存的数据。而栈指令则可以用于函数调整自己的栈空间大小。

最后需要说明的是，Go汇编语言可能并没有支持全部的CPU指令。如果遇到没有支持的CPU指令，可以通过Go汇编语言提供的BYTE命令将真实的CPU指令对应的机器码填充到对应的位置。完整的X86指令在 [https://github.com/golang/arch/blob/master/x86/x86.csv](https://github.com/golang/arch/blob/master/x86/x86.csv) 文件定义。同时Go汇编还正对一些指令定义了别名，具体可以参考这里 [https://golang.org/src/cmd/internal/obj/x86/anames.go](https://golang.org/src/cmd/internal/obj/x86/anames.go) 。

# 示例解说go汇编 

[腾讯：汇编是深入理解 Go 的基础](https://mp.weixin.qq.com/s/2JQM1piaWPQW-uwD_P-3Cg)

## 参考资料 

 * [腾讯：汇编是深入理解 Go 的基础](https://mp.weixin.qq.com/s/2JQM1piaWPQW-uwD_P-3Cg)
 * [Golang汇编命令解读](https://www.cnblogs.com/yjf512/p/6132868.html)
 * [https://mp.weixin.qq.com/s/9bn0foYfqJPtNdRI0NIleQ](https://mp.weixin.qq.com/s/9bn0foYfqJPtNdRI0NIleQ)
 * [https://www.zhihu.com/question/22609253](https://www.zhihu.com/question/22609253)
 * [https://colobu.com/2018/11/03/get-function-name-in-go](https://colobu.com/2018/11/03/get-function-name-in-go)
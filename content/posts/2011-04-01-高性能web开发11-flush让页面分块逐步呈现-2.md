---
title: 高性能WEB开发(11) – flush让页面分块,逐步呈现
author: admin
type: post
date: 2011-04-01T02:31:38+00:00
url: /archives/8844
IM_data:
 - 'a:1:{s:42:"http://berry.sinaapp.com/i/images/grey.gif";s:64:"http://blog.haohtml.com/wp-content/uploads/2011/04/ef42_grey.gif";}'
IM_contentdowned:
 - 1
categories:
 - 前端设计
tags:
 - 前端优化

---
在处理比较耗时的请求的时候，我们总希望先让用户先看到部分内容，让用户知道系统正在进行处理，而不是无响应。一般大家在处理这种情况，都使用 ajax，先把html输出到客户端，然后再用ajax取加载比较耗时的资源。用ajax麻烦的地方是增加了请求数，而且需要写额外的js代码、和js调 用的请求接口。

正对这种情况，还有一种处理方法，就是让response分块编码进行传输。response分块编码，可以先传输一部分不需要处理的html代码到客 户端，等其他耗时代码执行完毕后再传输另外的html代码。

**分块编码(chunked encoding)**

chunked encoding 是http1.1 才支持编码格式(当然目前没有哪个浏览器不支持1.1了)，chunked encoding 与一般的响应区别如下：



正常的响应：


HTTP/1.1 200 OK


Cache-Control: private, max-age=60


Content-Length: 75785


Content-Type: text/html; charset=utf-8


..其他response headers


chunked encoding 响应:


HTTP/1.1 200 OK


Cache-Control: private, max-age=60


Content-Length: 75785


Content-Type: text/html; charset=utf-8


**Transfer-Encoding: chunked**

..其他response headers


chunk #1(这里通常是16进制的数字，标志这个块的大小)


chunk #2


chunk #3


….




**实例(JSP)**

一个简单的页面，分为头部(header)和内容(部分)，假设内容部分需要读取数据库，花费3秒时间,然后显示csdn的logo。header部分显 示cnblogs的logo。代码如下：

[view source](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#viewSource "view source")

[print](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#printSource "print") [?](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#about "?")

`01``<` `body` `>`

`02`` ``<` `div` `id` `=` `"head"` `style` `=` `"border:1px solid #ccc;"` `>`

`03`` ``cnblogs logo <` `img` `src` `=` `"<a href="http://images.cnblogs.com/logo_small.gif">http://images.cnblogs.com/logo_small.gif</a>"` `/> `

`04`` ``</` `div` `>`

`05`` ``<` `br` `/>`

`06`` ``<` `div` `id` `=` `"content"` `style` `=` `"border:1px solid blue;"` `>`

`07`` ``<%`

`08`` ``// 睡眠3秒`

`09`` ``Thread.currentThread().sleep(3000);`

`10`` ``%>`

`11`` ``csdn logo<` `br` `/>`

`12`` ``<` `img` `src` `=` `"<a href="http://csdnimg.cn/www/images/csdnindex_piclogo.gif">http://csdnimg.cn/www/images/csdnindex_piclogo.gif</a>"` `/> `

`13`` ``</` `div` `>`

`14``</` `body` `>`

演示地址： [http://213.186.44.204:8080/ChunkTest/nochunk.jsp](http://213.186.44.204:8080/ChunkTest/nochunk.jsp) (服务器比较差，请大家温柔点)


打开这个演示地址发现很正常的页面，在3秒后才开始下载显示2个logo，资源加载瀑布图如下：


![](http://berry.sinaapp.com/i/images/grey.gif)

现在把代码改成如下，加上flush，让response把之前的html分块输出：


solid #ccc;”>


[view source](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#viewSource "view source")

[print](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#printSource "print") [?](http://www.cnblogs.com/BearsTaR/archive/2010/05/19/flush_chunk_encoding.html#about "?")

`01`` ``cnblogs logo <` `img` `src` `=` `"<a href="http://images.cnblogs.com/logo_small.gif">http://images.cnblogs.com/logo_small.gif</a>"` `/> `

`02``</` `div` `>`

`03``<%`

`04`` ``out.flush(); // flush response，分块输出`

`05``%>`

`06``<` `br` `/>`

`07``<` `div` `id` `=` `"content"` `style` `=` `"border:1px solid blue;"` `>`

`08`` ``<%`

`09`` ``// 睡眠3秒`

`10`` ``Thread.currentThread().sleep(3000);`

`11`` ``%>`

`12`` ``csdn logo<` `br` `/>`

`13`` ``<` `img` `src` `=` `"<a href="http://csdnimg.cn/www/images/csdnindex_piclogo.gif">http://csdnimg.cn/www/images/csdnindex_piclogo.gif</a>"` `/> `

`14``</` `div` `>`

演示地址： [http://213.186.44.204:8080/ChunkTest/chunk.jsp](http://213.186.44.204:8080/ChunkTest/chunk.jsp)

打开这个演示地址，是不是发现cnblogs logo先下载显示出来，3秒后csdn logo才显示，资源加载图如下：


![](http://berry.sinaapp.com/i/images/grey.gif)

从这个图发现，cnblogs的logo在jsp页面还没执行完就开始下载了，这就是分块输出的效果。


**监控工具：**

如何知道我们是否成功使用了chunk encoding了 ，只要用工具查看response header 中是否包含了Transfer-Encoding: chunked，如果包含了，则是分块了。但要想监控分块的详细信息，据我所知，目前只有httpwatch支持，可以查看我们到底分了多少块，但是数量 好像都多显示了1个，如下图：


![](http://berry.sinaapp.com/i/images/grey.gif)

有需要请查看： [高性能WEB开发系列](http://www.cnblogs.com/BearsTaR/archive/2010/05/12/web_performance.html)
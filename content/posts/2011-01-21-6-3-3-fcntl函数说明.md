---
title: 6.3.3 fcntl函数说明
author: admin
type: post
date: 2011-01-21T13:11:30+00:00
url: /archives/7558
IM_contentdowned:
 - 1
categories:
 - 程序开发
tags:
 - Linux

---

**（1）fcntl函数说明**

前面的这5个基本函数实现了文件的打开、读写等基本操作，这一节将讨论的是，在文 件已经共享的情况下如何操作，也就是当多个用户共同使用、操作一个文件的情况，这时，Linux 通常采用的方法是给文件上锁，来避免共享的资源产生竞争的状态。

文件锁包括建议性锁和强制性锁。

建议性锁要求每个上锁文件的进程都要检查是否有锁存，并且尊重已有的锁。在一般情况下，内核和系统都不使用建议性锁。强制性锁是由内 核执行的锁，当一个文件被上锁进行写入操作的时候，内核将阻止其他任何文件对其进行读写操作。采用强制性锁对性能的影响很大，每次读写操作都必须检查是否有锁存在。

在 Linux 中，实现文件上锁的函数有lock和fcntl，其中flock用于对文件施加建议性锁,而fcntl不仅可以施加建议性锁，还可以施加强制锁。同时，fcntl还能对文件的某一记录进行上锁，也就是记录锁。

记录锁又可分为读取锁和写入锁，其中读取锁又称为共享锁，它能够使多个进程都能在文件的同一部分建立读取锁。而写入锁又称为排斥锁，在任何时刻只能有一个进程在文件的某个部分上建立写入锁。当然，在文件的同一部分不能同时建立读取锁和写入锁。

注意:

fcntl是一个非常通用的函数，它还可以改变文件进程各方面的属性，在本节中，主要介绍它建立记录锁的方法，关于它其他用户感兴趣的读者可以参看fcntl手册。

**（2）fcntl函数格式**

用于建立记录锁的fcntl函数格式如表6.6 所示。

表6.6 fcntl函数语法要点所需头文件

>

> #include
>

>
>

> #include
>

>
>

> #include
>

函数原型int fcnt1(int fd, int cmd, struct flock *lock)

**fd：文件描述符**

F_DUPFD：复制文件描述符

F_GETFD：获得fd的close-on-exec标志，若标志未设置，则文件经过exec函数之后仍保持打开状态

F_SETFD：设置close-on-exec标志，该标志以参数arg的FD_CLOEXEC位决定

F_GETFL：得到open设置的标志

**函数传入值**

cmd

F_SETFL：改变open设置的标志

F_GETFK：根据lock描述，决定是否上文件锁

F_SETFK：设置lock描述的文件锁

F_SETLKW：这是F_SETLK的阻塞版本（命令名中的W表示等待（wait））。

如果存在其他锁，则调用进程睡眠；如果捕捉到信号则睡眠中断

F_GETOWN：检索将收到SIGIO和SIGURG信号的进程号或进程组号

F_SETOWN：设置进程号或进程组号

**函数返回值**

**Lock：** 结构为flock，设置记录锁的具体状态，后面会详细说明

成功：0

 -1：出错

这里，lock的结构如下所示：

>

> Struct flock{
>

>
>

> short l_type;
>

>
>

> off_t l_start;
>

>
>

> short l_whence;
>

>
>

> off_t l_len;
>

>
>

> pid_t l_pid;
>

>
>

> }
>

lock结构中每个变量的取值含义如表6.7 所示。

**表6.7 lock结构变量取值**

>

> F_RDLCK：读取锁（共享锁）
>

>
>

> l_type F_WRLCK：写入锁（排斥锁）
>

>
>

> F_UNLCK：解锁
>

>
>

> l_stat 相对位移量（字节）
>

>
>

> SEEK_SET：当前位置为文件的开头，新位置为偏移量的大小
>

>
>

> SEEK_CUR：当前位置为文件指针的位置，新位置为当前位置加上偏移量
>

>
>

> l_whence：相对位移量的起点（同lseek 的whence）。
>

>
>

> SEEK_END：当前位置为文件的结尾，新位置为文件的大小加上偏移量的大小
>

>
>

> l_len 加锁区域的长度
>

小技巧:

为加锁整个文件，通常的方法是将l_start 说明为0，l_whence 说明为SEEK_SET，l_len 说明为0。

**（3）fcntl使用实例**

下面首先给出了使用fcntl 函数的文件记录锁函数。在该函数中，首先给flock 结构体的对应位赋予相应的值。接着使用两次fcntl函数分别用于给相关文件上锁和判断文件是否可以上锁，这里用到的cmd值分别为F_SETLK 和F_GETLK。

这个函数的源代码如下所示：

>

> /*lock_set函数*/
>

>
>

> void lock_set(int fd, int type)
>

>
>

> {
>

>
>

> struct flock lock;
>

>
>

> lock.l_whence = SEEK_SET;//赋值lock结构体
>

>
>

> lock.l_start = 0;
>

>
>

> lock.l_len =0;
>

>
>

> while(1){
>

>
>

> lock.l_type = type;
>

>
>

> /*根据不同的type值给文件上锁或解锁*/
>

>
>

> if((fcntl(fd, F_SETLK, &lock)) == 0){
>

>
>

> if( lock.l_type == F_RDLCK )
>

>
>

> printf(“read lock set by %d\n”,getpid());
>

>
>

> else if( lock.l_type == F_WRLCK )
>

>
>

> printf(“write lock set by %d\n”,getpid());
>

>
>

> else if( lock.l_type == F_UNLCK )
>

>
>

> printf(“release lock by %d\n”,getpid());
>

>
>

> return;
>

>
>

> }
>

>
>

> /*判断文件是否可以上锁*/
>

>
>

> fcntl(fd, F_GETLK,&lock);
>

>
>

> /*判断文件不能上锁的原因*/
>

>
>

> if(lock.l_type != F_UNLCK){
>

>
>

> /*/该文件已有写入锁*/
>

>
>

> if( lock.l_type == F_RDLCK )
>

>
>

> printf(“read lock already set by %d\n”,lock.l_pid);
>

>
>

> /*该文件已有读取锁*/
>

>
>

> else if( lock.l_type == F_WRLCK )
>

>
>

> printf(“write lock already set by %d\n”,lock.l_pid);
>

>
>

> getchar();
>

>
>

> }
>

>
>

> }
>

>
>

> }
>

下面的实例是测试文件的写入锁，这里首先创建了一个hello文件，之后对其上写入锁，最后释放写入锁。代码如下所示：

>

> /*fcntl_write.c测试文件写入锁主函数部分*/
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> int main(void)
>

>
>

> {
>

>
>

> int fd;
>

>
>

> /*首先打开文件*/
>

>
>

> fd=open(“hello”,O_RDWR | O_CREAT, 0666);
>

>
>

> if(fd < 0){
>

>
>

> perror(“open”);
>

>
>

> exit(1);
>

>
>

> }
>

>
>

> /*给文件上写入锁*/
>

>
>

> lock_set(fd, F_WRLCK);
>

>
>

> getchar();
>

>
>

> /*给文件接锁*/
>

>
>

> lock_set(fd, F_UNLCK);
>

>
>

> getchar();
>

>
>

> close(fd);
>

>
>

> exit(0);
>

>
>

> }
>

为了能够使用多个终端，更好地显示写入锁的作用，本实例主要在PC 机上测试，读者可将其交叉编译，下载到目标板上运行。下面是在PC 机上的运行结果。为了使程序有较大的灵活性，笔者采用文件上锁后由用户键入一任意键使程序继续运行。建议读者开启两个终端，并且在两个终端上同时运行该程序，以达到多个进程操作一个文件的效果。在这里，笔者首先运行终端一，请读者注意终端二中的第一句。

终端一：

>

> [root@localhost file]# ./fcntl_write
>

>
>

> write lock set by 4994
>

>
>

> release lock by 4994
>

终端二：

>

> [root@localhost file]# ./fcntl_write
>

>
>

> write lock already set by 4994
>

>
>

> write lock set by 4997
>

>
>

> release lock by 4997
>

由此可见，写入锁为互斥锁，一个时刻只能有一个写入锁存在。

接下来的程序是测试文件的读取锁，原理同上面的程序一样。

>

> /*fcntl_read.c测试文件读取锁主函数部分*/
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> #include
>

>
>

> int main(void)
>

>
>

> {
>

>
>

> int fd;
>

>
>

> fd=open(“hello”,O_RDWR | O_CREAT, 0666);
>

>
>

> if(fd < 0){
>

>
>

> perror(“open”);
>

>
>

> exit(1);
>

>
>

> }
>

>
>

> /*给文件上读取锁*/
>

>
>

> lock_set(fd, F_RDLCK);
>

>
>

> getchar();
>

>
>

> /*给文件接锁*/
>

>
>

> lock_set(fd, F_UNLCK);
>

>
>

> getchar();
>

>
>

> close(fd);
>

>
>

> exit(0);
>

>
>

> }
>

同样开启两个终端，并首先启动终端一上的程序，其运行结果如下所示：

终端一:

>

> [root@localhost file]# ./fcntl2
>

>
>

> read lock set by 5009
>

>
>

> release lock by 5009
>

终端二：

>

> [root@localhost file]# ./fcntl2
>

>
>

> read lock set by 5010
>

>
>

> release lock by 5010
>

读者可以将此结果与写入锁的运行结果相比较，可以看出，读取锁为共享锁，当进程5009已设定读取锁后，进程5010 还可以设置读取锁。

思考:

如果在一个终端上运行设置读取锁，则在另一个终端上运行设置写入锁，会有什么结果呢？
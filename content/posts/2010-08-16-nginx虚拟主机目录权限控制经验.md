---
title: nginx虚拟主机目录权限控制经验
author: admin
type: post
date: 2010-08-16T14:32:14+00:00
url: /archives/5121
IM_contentdowned:
 - 1
categories:
 - 服务器
tags:
 - 虚拟主机
 - nginx

---
关于Nginx的配置文件，不支持php\_admin\_value open\_basedir，也就是Nginx暂时还没有 Apache的 php\_myadmin_value这类的设置。如果用Nginx做虚拟主机，各用户之间的目录安全控制如何来做呢？网上很多人说，限制上传文件类型，做好程序安全不就行了么？对，对于自己的站点来说这样完全可以。但如果虚拟主机是给别人用的，又给予了FTP权限，总不能不让人上传php 文件吧。参考以上，如果用Nginx来做虚拟主机，目前看来安全的配置方法是：

**1、用低权限账号运行Nginx。**

**2、在php.ini中禁用危险的函数。**

如：system,passthru,shell_exec,exec,popen,proc_open,chroot,scandir,chgrp,chown,

 passthru,shell_exec,ini_alter,ini_alter,ini_restore,dl,pfsockopen,

 openlog,syslog,readlink,symlink,popepassthru,stream_socket_server等，但禁止太多的函数可能对某些php程序的正常运行产生影响。

**3、在php.ini中设置open_basedir**

如：open\_basedir = “:/tmp/:/var/tmp/:/usr/local/webserver/nginx /html/www.xpb.cn\_7da347bc1a9fd621/:/usr/local/webserver/nginx/html/www2.xpb.cn_7da347bc1a9fd621/”

**4、各个虚拟主机用户放在不易于猜到的目录**

如：www.xpb.cn\_7da347bc1a9fd621、www2.xpb.cn\_7da347bc1a9fd621

**5、自己找一个php木马，自我测试服务器安全！**

6、【2009年7月17日更新】据网上部分资料说，在运行spawn-fcgi 的时候带上参数 -d open\_basedir 即可，例如：/usr /sbin/spawn-fcgi -a 127.0.0.1 -p 10080 -C 20 -u www -f “/usr/sbin/php-cgi -d open\_basedir=/var/www/wwwroot/:/tmp/”

**7、参见下面Rainy fox 给出的解决方案。**

本方法由于时间原因暂时未做测试验证，大家可以尝试一下，如果可以，相对于以上的几条，应该是比较好的解决方案。

另外，暂时还未发现专门针对Nginx的虚拟主机管理软件，如果有知道的可以麻烦说下。

看来，在虚拟主机上还是Apache是王道，几乎所有的虚拟主机提供商的专业PHP虚拟主机仍然采用Apache。期待Nginx能够尽快完善这方面的功能设置！有更好解决方法的，也烦请告知。

顺便提示一下，并非用apache就安全，也并非用linux就安全。在windows下使用Apache，务必配置一下open_basedir ，甚至 Apache运行权限，因为默认Apache是以system权限运行的，如果站点一旦被上传木马，则会十分危险，当然Linux下的也要设置一下，相信熟悉linux的都应当熟悉，不再赘述。

先来看两份配置文件的部分，只跟大家讲原理，省略了和主题无关的部分，请勿复制就用，明白了原理，就知道该怎么做了。

php.ini

; open_basedir, if set, limits all file operations to the defined directory
; and below. This directive makes most sense if used in a per-directory
; or per-virtualhost web server configuration file. This directive is
; \*NOT\* affected by whether Safe Mode is turned On or Off.
open_basedir = “/myserver/:/tmp/:/var/tmp/”
nginx.conf

http
{
server
{
listen 80;
server_name host1.com;
root /myserver/host1;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
server
{
listen 80;
server_name host2.com;
root /myserver/host2;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
server
{
listen 80;
server_name host3.com;
root /myserver/host3;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
}
配置的基本情况是 运行3个网站 host1.com host2.com host3.com ，php.ini的配置，限制php脚本只能在这三个网站目录的父目录 /myserver/ 下面执行。

这时候我们知道，如果在某一个站点上上传了一个php木马，那么这个木马将可以访问其他两个站点的文件。nignx 没有apache那样能够单独设置每个网站的php只能在本目录下访问的功能。这时候我们就要用一点取巧的办法了。

来看这个php.ini的配置。
open_basedir = “/myserver/:/tmp/:/var/tmp/”
其实这个路径也支持 (.) [一个点] 和 (..) [两个点]，也就是当前目录、父目录。于是有下面的配置方法

open_basedir = “.:/tmp/:/var/tmp/” 把php文件限制在当前目录，的确，这样确实是访问不到别的两个网站的目录了，但是访问某些页面会出现 No input file specified. 。

为什么呢，因为上面的这个限制，当你运行或者引用了网站目录下的子目录(或者子目录的子目录….)里的php文件(假定为/myserver /host1/dir1/myphp.php)，而这个子目录文件又要访问上级目录里的文件(/myserver/host1/config.php)，这时候问题就来了，php.ini里设置了myphp.php只能访问该本级目录(/myserver/host1/dir1/)以下的文件，而不能访问 /myserver/host1下的直接文件，于是提示：No input file specified.

现在解决办法来了

再看两个配置文件：

下面的这个 /subX1/subX2/subX3/……….(N层) ，N为你网站上最底层的php文件嵌套级数，如果你网站最多有5级子目录下有php文件，那么就嵌套5层以上。

php.ini

; open_basedir, if set, limits all file operations to the defined directory
; and below. This directive makes most sense if used in a per-directory
; or per-virtualhost web server configuration file. This directive is
; \*NOT\* affected by whether Safe Mode is turned On or Off.
open_basedir = “../../…….(N层):/tmp/:/var/tmp/”
nginx.conf

http
{
server
{
listen 80;
server_name host1.com;
root /myserver/subA1/subA2/subA3/……….(N层)/host1;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
server
{
listen 80;
server_name host2.com;
root /myserver/subB1/subB2/subB3/……….(N层)/host2;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
server
{
listen 80;
server_name host3.com;
root /myserver/subC1/subC2/subC3/……….(N层)/host3;

location ~ .*\.(php|php5)?$
{
#fastcgi_pass unix:/tmp/php-cgi.sock;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
}
}
举例N等于5….运行，当访问最底层的php文件 /myserver/subA1/subA2/subA3/subA4/subA5/host1 /dir1/dir2/dir3/dir4/myphp.php，这个php文件所能访问的上级层到 /myserver/subA1/subA2 /subA3/subA4/subA5/host1，当访问 /myserver/subA1/subA2/subA3/subA4/subA5 /host1/myphp2.php 文件时候，它所能最多访问到的上级层 /myserver/subA1 ，不能跃出访问到其他站目录里的文件

这样就限制了该站目录下的php程序不能访问别的网站，而对自己网站的访问又充分不受限制。很简单，到此结束。

关于Nginx：

1、简介
Nginx (”engine x”) 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过四年半了。Igor 将源代码以类BSD许可证的形式发布。尽管还是测试版，但是，Nginx 已经因为它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名了。更多的请见官方wiki: http://wiki.codemongers.com/

2、 Nginx的优点

nginx做为HTTP服务器，有以下几项基本特性：
1) 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．
2) 无缓存的反向代理加速，简单的负载均衡和容错．
3) FastCGI，简单的负载均衡和容错．
4) 模块化的结构。包括gzipping, byte ranges, chunked responses, 以及 SSI-filter等filter。如

果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。
5) 支持SSL 和 TLS SNI．

Nginx专为性能优化而开发，性能是其最重要的考量, 实现上非常注重效率 。它支持内核Poll模型，能经受高负载的考验, 有报告表明能支持高达 50,000 个并发连接数。

Nginx 具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言, nginx比lighthttpd更胜一筹。

Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。

Nginx采用master-slave模型, 能够充分利用SMP的优势，且能够减少工作进程在磁盘I/O的阻塞延迟。当采用select()/poll()调用时，还可以限制每个进程的连接数。

Nginx 代码质量非常高，代码很规范， 手法成熟， 模块扩展也很容易。特别值得一提的是强大的Upstream与Filter链。 Upstream为诸如 reverse proxy, 与其他服务器通信模块的编写奠定了很好的基础。而Filter链最酷的部分就是各个filter不必等待前一个 filter执行完毕。它可以把前一个filter的输出做为当前filter的输入，这有点像Unix的管线。这意味着，一个模块可以开始压缩从后端服务器发送过来的请求，且可以在模块接收完后端服务器的整个请求之前把压缩流转向客户端。

Nginx采用了一些os提供的最新特性如对sendfile (Linux 2.2+)，accept-filter (FreeBSD 4.1+)，TCP\_DEFER\_ACCEPT (Linux 2.4+) 的支持，从而大大提高了性能。

来源:
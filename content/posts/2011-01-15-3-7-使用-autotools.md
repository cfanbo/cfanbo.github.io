---
title: 3.7 使用 autotools
author: admin
type: post
date: 2011-01-15T11:39:21+00:00
url: /archives/7520
IM_contentdowned:
 - 1
categories:
 - 服务器
tags:
 - ma
 - make

---
在上一小节，读者已经了解到了make 项目管理器的强大功能。的确，Makefile 可以帮助make 完成它的使命，但要承认的是，编写Makefile 确实不是一件轻松的事，尤其对于一个较大的项目而言更是如此。那么，有没有一种轻松的手段生成Makefile而同时又能让用户享受make 的优越性呢？本节要讲的autotools 系列工具正是为此而设的，它只需用户输入简单的目标文件、依赖文件、文件目录等就可以轻松地生成Makefile了，这无疑是广大用户的所希望的。另外，这些工具还可以完成系统配置信息的收集，从而可以方便地处理各种移植性的问题。也正是基于此，现在Linux 上的软件开发一般都用autotools 来制作Makefile，读者在后面的讲述中就会了解到。

**3.7.1 autotools使用流程**

正如前面所言，autotools 是系列工具，读者首先要确认系统是否装了以下工具（可以用which命令进行查看）。

 * · aclocal
 * · autoscan
 * · autoconf
 * · autoheader
 * · automake

使用autotools主要就是利用各个工具的脚本文件以生成最后的Makefile。其总体流程是这样的。

 1. 使用aclocal生成一个“aclocal.m4”文件，该文件主要处理本地的宏定义；
 2. 改写“configure.scan”文件，并将其重命名为“configure.in”，并使用autoconf 文件生成configure文件。

接下来，笔者将通过一个简单的hello.c例子带领读者熟悉autotools生成makefile的过程，由于在这过程中有涉及较多的脚本文件，为了更清楚地了解相互之间的关系，强烈建议读者实际动手操作以体会其整个过程。

**1．autoscan**

它会在给定目录及其子目录树中检查源文件，若没有给出目录，就在当前目录及其子目录树中进行检查。它会搜索源文件以寻找一般的移植性问题并创建一个文件“configure.scan”，该文件就是接下来autoconf要用到的“configure.in”原型。如下所示：

> [root@localhost automake]# **autoscan**
>
> autom4te: configure.ac: no such file or directory
>
> autoscan: /usr/bin/autom4te failed with exit status: 1

> [root@localhost automake]# ls
>
> autoscan.log **configure.scan** hello.c

由上述代码可知autoscan首先会尝试去读入“configure.ac”（同configure.in的配置文件）文件，此时还没有创建该配置文件，于是它会自动生成一个“configure.in”的原型文件

“configure.scan”。

**2．autoconf**

configure.in是autoconf的脚本配置文件，它的原型文件“configure.scan”如下所示：

> \# -\*- Autoconf -\*-
>
> \# Process this file with autoconf to produce a configure script.
>
> AC_PREREQ(2.59)
>
> #The next one is modified by sunq
>
> #AC_INIT(FULL-PACKAGE-NAME,VERSION,BUG-REPORT-ADDRESS)
>
> AC_INIT(hello,1.0)
>
> \# The next one is added by sunq
>
> AM\_INIT\_AUTOMAKE(hello,1.0)
>
> AC\_CONFIG\_SRCDIR([hello.c])
>
> AC\_CONFIG\_HEADER([config.h])
>
> \# Checks for programs.
>
> AC\_PROG\_CC
>
> \# Checks for libraries.
>
> \# Checks for header files.
>
> \# Checks for typedefs, structures, and compiler characteristics.
>
> \# Checks for library functions.
>
> AC\_CONFIG\_FILES([Makefile])
>
> AC_OUTPUT

下面对这个脚本文件进行解释。

 * · 以“#”号开始的行为注释。
 * · AC_PREREQ 宏声明本文件要求的autoconf版本，如本例使用的版本2.59。
 * ·AC_INIT宏用来定义软件的名称和版本等信息，在本例中省略了BUG-REPORT-ADDRESS，

一般为作者的E-mail。

 * · AM\_INIT\_AUTOMAKE 是笔者另加的，它是automake所必备的宏，也同前面一样，

PACKAGE 是所要产生软件套件的名称，VERSION 是版本编号。

 * · AC\_CONFIG\_SRCDIR宏用来侦测所指定的源码文件是否存在，来确定源码目录的有

效性。在此处为当前目录下的hello.c。

 * · AC\_CONFIG\_HEADER宏用于生成config.h文件，以便autoheader 使用。
 * · AC\_CONFIG\_FILES宏用于生成相应的Makefile 文件。
 * · 中间的注释间可以添加分别用户测试程序、测试函数库、测试头文件等宏定义。

接下来首先运行aclocal，生成一个“aclocal.m4”文件，该文件主要处理本地的宏定义。

如下所示：

> [root@localhost automake]# **aclocal**

再接着运行autoconf，生成“configure”可执行文件。如下所示：

> [root@localhost automake]# **autoconf**
>
> [root@localhost automake]# **ls**
>
> aclocal.m4 autom4te.cache autoscan.log **configure** ****configure.in hello.c

**3．autoheader**

接着使用autoheader 命令，它负责生成config.h.in文件。该工具通常会从“acconfig.h”文件中复制用户附加的符号定义，因此此处没有附加符号定义，所以不需要创建“acconfig.h”

文件。如下所示：

> [root@localhost automake]# **autoheader**

**4．automake**

这一步是创建Makefile 很重要的一步，automake 要用的脚本配置文件是Makefile.am，用户需要自己创建相应的文件。之后，automake工具转换成Makefile.in。在该例中，笔者创建的文件为Makefile.am如下所示：

> AUTOMAKE_OPTIONS=foreign
>
> bin_PROGRAMS= hello
>
> hello_SOURCES= hello.c

下面对该脚本文件的对应项进行解释。

 * · 其中的AUTOMAKE_OPTIONS为设置automake 的选项。由于GNU（在第1章中已经有所介绍）对自己发布的软件有严格的规范，比如必须附带许可证声明文件COPYING 等，否则automake执行时会报错。automake提供了3 种软件等级：foreign、gnu和gnits，让用户选择采用，默认等级为gnu。在本例使用foreign等级，它只检测必须的文件。

 * · bin_PROGRAMS定义要产生的执行文件名。如果要产生多个执行文件，每个文件名用空格隔开。

 * · hello\_SOURCES 定义“hello”这个执行程序所需要的原始文件。如果“hello”这个程序是由多个原始文件所产生的，则必须把它所用到的所有原始文件都列出来，并用空格隔开。例如：若目标体“hello”需要“hello.c”、“sunq.c”、“hello.h”三个依赖文件，则定义hello\_SOURCES=hello.c sunq.c hello.h。要注意的是，如果要定义多个执行文件，则对每个执行程序都要定义相应的file_SOURCES。

接下来可以使用automake 对其生成“configure.in”文件，在这里使用选项 “—adding-missing” 可以让automake自动添加有一些必需的脚本文件。如下所示：

> [root@localhost automake]# **automake –add-missing**
>
> configure.in: installing ‘./install-sh’
>
> configure.in: installing ‘./missing’
>
> Makefile.am: installing ‘depcomp’
>
> [root@localhost automake]# **ls**
>
> aclocal.m4 autoscan.log **configure.in** hello.c Makefile.am missing
>
> autom4te.cache configure depcomp install-sh Makefile.in config.h.in
>
> 可以看到，在automake之后就可以生成configure.in文件。

**5．运行configure**

在这一步中，通过运行自动配置设置文件configure，把Makefile.in 变成了最终的Makefile。如下所示：

> [root@localhost automake]# **./configure**
>
> checking for a BSD-compatible install… /usr/bin/install -c
>
> checking whether build enVironment is sane… yes
>
> checking for gawk… gawk
>
> checking whether make sets $(MAKE)… yes
>
> checking for Gcc… Gcc
>
> checking for C compiler default output file name… a.out
>
> checking whether the C compiler works… yes
>
> checking whether we are cross compiling… no
>
> checking for suffix of executables…
>
> checking for suffix of object files… o
>
> checking whether we are using the GNU C compiler… yes
>
> checking whether Gcc accepts -g… yes
>
> checking for Gcc option to accept ANSI C… none needed
>
> checking for style of include used by make… GNU
>
> checking dependency style of Gcc… Gcc3
>
> configure: creating ./config.status
>
> config.status: **creating Makefile**
>
> config.status: executing depfiles commands

可以看到，在运行configure 时收集了系统的信息，用户可以在configure 命令中对其进行方便地配置。在./configure 的自定义参数有两种，一种是开关式（–enable-XXX 或–disable-XXX），另一种是开放式，即后面要填入一串字符（–with-XXX=yyyy）参数。读者可以自行尝试其使用方法。另外，读者可以查看同一目录下的“config.log”文件，以方便调试之用。

到此为止，makefile就可以自动生成了。回忆整个步骤，用户不再需要定制不同的规则，而只需要输入简单的文件及目录名即可，这样就大大方便了用户的使用。autotools 生成

Makefile流程图如图3.9 所示。

> **./configure**
>
> **automake**
>
> configure.scan
>
> aclocal.m4 configure.in
>
> Makefile.am
>
> Makefile.in
>
> config.in.h
>
> configure
>
> **autoscan**
>
> **aclocal autoheader**
>
> Makefile.am

图3.9 autotools生成Makefile流程图

**3.7.2 使用autotools所生成的Makefile**

autotools生成的Makefile除具有普通的编译功能外，还具有以下主要功能（感兴趣的读者可以查看这个简单的hello.c程序的makefile）。

1．make

键入make默认执行“make all”命令，即目标体为all，其执行情况如下所示：

> [root@localhost automake]# **make**
>
> if Gcc -DPACKAGE\_NAME=\”\” -DPACKAGE\_TARNAME=\”\” -DPACKAGE_VERSION=\”\”
>
> -DPACKAGE\_STRING=\”\” -DPACKAGE\_BUGREPORT=\”\” -DPACKAGE=\”hello\” -DVERSION=\”1.0\”
>
> -I. -I. -g -O2 -MT hello.o -MD -MP -MF “.deps/hello.Tpo” -c -o hello.o hello.c; \
>
> then mv -f “.deps/hello.Tpo” “.deps/hello.Po”; else rm -f “.deps/hello.Tpo”;
>
> exit 1; fi
>
> **Gcc -g -O2 -o hello hello.o**

此时在本目录下就生成了可执行文件“hello”，运行“./hello”能出现正常结果，如下所示：

> [root@localhost automake]# **./hello**
>
> Hello!Autoconf!

2．make install

此时，会把该程序安装到系统目录中去，如下所示：

> [root@localhost automake]# **make install**
>
> if Gcc -DPACKAGE\_NAME=\”\” -DPACKAGE\_TARNAME=\”\” -DPACKAGE_VERSION=\”\”
>
> -DPACKAGE\_STRING=\”\” -DPACKAGE\_BUGREPORT=\”\” -DPACKAGE=\”hello\” -DVERSION=\”1.0\”
>
> -I. -I. -g -O2 -MT hello.o -MD -MP -MF “.deps/hello.Tpo” -c -o hello.o hello.c; \
>
> then mv -f “.deps/hello.Tpo” “.deps/hello.Po”; else rm -f “.deps/hello.Tpo”;
>
> exit 1; fi
>
> **Gcc -g -O2 -o hello hello.o**
>
> make[1]: Entering directory ‘/root/workplace/automake’
>
> **test -z “/usr/local/bin” || mkdir -p — “/usr/local/bin”**
>
> **/usr/bin/install -c ‘hello’ ‘/usr/local/bin/hello’**
>
> make[1]: Nothing to be done for ‘install-data-am’.
>
> make[1]: LeaVing directory ‘/root/workplace/automake’

此时，若直接运行hello，也能出现正确结果，如下所示：

> [root@localhost automake]# **hello**
>
> Hello!Autoconf!

3．make clean

此时，make会清除之前所编译的可执行文件及目标文件（object file, *.o），如下所示：

> [root@localhost automake]# **make clean**
>
> test -z “hello” || rm -f hello
>
> **rm -f *.o**

4．make dist

此时，make将程序和相关的文档打包为一个压缩文档以供发布，如下所示：

> [root@localhost automake]# **make dist**
>
> [root@localhost automake]# ls hello-1.0-tar.gz
>
> hello-1.0-tar.gz

可见该命令生成了一个hello-1.0-tar.gz 的压缩文件。

由上面的讲述读者不难看出，autotools 确实是软件维护与发布的必备工具，鉴于此，如今GUN 的软件一般都是由automake来制作的。

想一想对于automake制作的这类软件，应如何安装呢？
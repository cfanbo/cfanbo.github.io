---
title: C语言中 static 和 const
author: admin
type: post
date: 2011-08-05T11:12:21+00:00
url: /archives/10881
IM_contentdowned:
 - 1
categories:
 - 程序开发
tags:
 - c语言
 - const

---
static 的两大作用:

**一、控制存储方式：**

static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间。

1、引出原因：函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？
最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。

2、 解决方案：因此c++ 中引入了static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的存取范围不变。

**二、控制可见性与连接类型 :**

static还有一个作用，它会把变量的可见范围限制在编译单元中，使它成为一个内部连接，这时，它的反义词为”extern”.

static作用分析总结：static总是使得变量或对象的存储形式变成静态存储，连接方式变成内部连接，对于局部变量（已经是内部连接了），它仅改变其存储方式；对于全局变量（已经是静态存储了），它仅改变其连接类型。

**类中的static成员：**

**一、出现原因及作用：**

1、需要在一个类的各个对象间交互，即需要一个数据对象为整个类而非某个对象服务。

2、同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。

类的static成员满足了上述的要求，因为它具有如下特征：
(1)静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。

(2)静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。

(3)允许对构造类静态局部量赋初值。在数组一章中，介绍数组初始化时已作过说明。若未赋以初值，则由系统自动赋以0值。

(4)对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。 根据静态局部变量的特点，可以看出它是一种生存期为整个源程序的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。

# 二、注意：

1、对于静态的数据成员，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

2、类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。

const 是c++中常用的类型修饰符，但我在工作中发现，许多人使用它仅仅是想当然尔，这样,有时也会用对，但在某些微妙的场合，可就没那么幸运了，究其实质原由，大多因为没有搞清本源。故在本篇中我将对const进行辨析。溯其本源，究其实质，希望能对大家理解const有所帮助，根据思维的承接关系，分为如下几个部分进行阐述。

c++中为什么会引入const

c++的提出者当初是基于什么样的目的引入（或者说保留）const关键字呢？，这是一个有趣又有益的话题，对理解const很有帮助。

1． 大家知道，c++有一个类型严格的编译系统，这使得c++程序的错误在编译阶段即可发现许多，从而使得出错率大为减少，因此，也成为了c++与c相比，有着突出优点的一个方面。

2． c中很常见的预处理指令 #define variablename variablevalue 可以很方便地进行值替代，这种值替代至少在三个方面优点突出：

一是避免了意义模糊的数字出现，使得程序语义流畅清晰，如下例：
#define user\_num\_max 107 这样就避免了直接使用107带来的困惑。

二是可以很方便地进行参数的调整与修改，如上例，当人数由107变为201时，进改动此处即可，

三是提高了程序的执行效率，由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。

鉴于以上的优点，这种预定义指令的使用在程序中随处可见。

3． 说到这里，大家可能会迷惑上述的1点、2点与const有什么关系呢?,好，请接着向下

看来：

预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受c++严格类型检查的好处，从而可能成为引发一系列错误的隐患。

4．好了，第一阶段结论出来了：
结论： const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。

现在它的形式变成了：

const datatype variablename = variablevalue ;
为什么const能很好地取代预定义语句？
const 到底有什么大神通，使它可以振臂一挥取代预定义语句呢？

1． 首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。

2． 第二，很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。

3． 第三，c++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高，同时，这也是它取代预定义语句的重要基础。这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。

4． 最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。

const 使用情况分类详析

1.const 用于指针的两种情况分析：

#  int const *a; 　file://a可变，*a不可变

 int *const a; 　file://a不可变，*a可变

分析：const 是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定 \*a,不限定a。int \*const 限定a,不限定*a。

2.const 限定函数的传递值参数：

void fun(const int var);

分析：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。
结论：最好在函数的内部进行限定，对外部调用者屏蔽，以免引起困惑。如可改写如下：

void fun(int var){
const int & varalias = var;

varalias ….

…..

}

3.const 限定函数的值型返回值：

const int fun1();

const myclass fun2();

分析:上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。

4. 传递与返回地址： 此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。

5.　const 限定类的成员函数：
class classname {
public:

int fun() const;

…..

}

注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。

获得能力：可以操作常量对象。

失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。

对于在类中的static应用，为楼主补充一个简单的例子以说明其功能：）



在类中可以使用关键字static定义静态成员变量和静态成员函数，它们都具有特殊的用途。
当为一个类定义了一个静态成员变量后，该变量对于该类的所有对象来说，只有一个拷贝，也就是为该类的所有对象共用。基于此，静态成员变量可以用来表示一些特殊的属性，比如对于该类当前的对象来说，该属性必须是一致的。其中的某一个对象修改了该属性，则所有其他对象的该属性值都被修改了。也可以说，类的静态成员变量是一个公共变量，只不过公用的范围只限于该类的对象。
静态成员变量可以初始化和赋值。在初始化和赋值时只要利用作用域运算符“ : :”指定类名即可。对于私有类型的静态成员变量可以象公有类型的静态成员变量一样赋值，但是不可以直接引用。
另外，可以使用静态成员变量来表示当前该类所有对象的个数。在一开始将静态成员变量清零，并在类的构造函数中将此静态成员变量增加1，在析构函数中将此变量减1。这样，就可以随时确定当前对象的个数。
静态成员函数中实现的代码是一些与具体对象无关的代码，是来实现该类全体对象通用的任务。

所以，对于静态成员函数有下面的一些约束：
? 静态成员函数的定义体中不可以对非静态成员变量进行操作。
? 静态成员函数中不可以调用非静态成员函数。
? 静态成员函数中不能使用this指针。
通常，构造函数和析构函数不可以是静态成员函数。
下面通过例程说明静态成员变量和静态成员函数的用法。

＃i nclude
＃i nclude
class Rabbit
{
public:
Rabbit(); // 默认构造函数
~ Rabbit(); // 析构函数
static int GetNum(); // 公有类型的静态成员函数
static int Num; // 公有类型的静态成员变量
};
Rabbit::Rabbit()
{
Num++;
}
Rabbit::~ Rabbit()
{
Num–;
}
int Rabbit::GetNum()
{
return Num;
}
int Rabbit::Num=0; // 对静态公有成员变量进行初始化
void main()
{
Rabbit r1,r2; // 将调用默认的构造函数
// 公有类型的静态成员变量可以直接引用
cout<<“Num of Rabbits is “<
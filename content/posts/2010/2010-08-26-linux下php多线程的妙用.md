---
title: linux下php多线程的妙用
author: admin
type: post
date: 2010-08-26T13:44:51+00:00
url: /archives/5327
IM_contentdowned:
 - 1
categories:
 - 程序开发
tags:
 - php

---
开始用php写后台服务一段时间了.也是在这样的驱动下,不断的学习php语法,体验这一原来一直以为神秘且敬而远之的神奇语言的魅力.最初看php多线程的资料是为了提高程序的处理能力,充分发挥linux多任务的优势.不曾想多线程没用成反到是带来了一系列的意外收获.让之后的许多问题迎刃而解,不敢独享特一一道来.
本文所讲的东西是源自php的pcntl_fork函数.因为这个函数依赖操作系统fork的实现,所以本文所讲的东西只适用于linux/unix.ok,那么先看看这个函数的用法吧. [php手册](http://cn.php.net/manual/en/function.pcntl-fork.php) 上是这么说的:

$pid = pcntl_fork();

if ($pid == -1) {

die(‘could not fork’);

} else if ($pid) {

// we are the parent

pcntl_wait($status); //Protect against Zombie children

} else {

// we are the child

}

?>


通过pcntl_fork创建一个子进程,如果返回值是-1的话,那么说明子进程创建失败.创建成功的进程id会返回给父进程,0返回给子进程.不好理解吧,费了很常时间明白以后,笔者习惯这样写:

$pid = pcntl_fork();

if($pid == -1){

//创建失败咱就退出呗,没啥好说的

die(‘could not fork’);

}

else{

if($pid){

//从这里开始写的代码是父进程的,因为写的是系统程序,记得退出的时候给个返回值

exit(0);

}

else{

//从这里开始写的代码都是在新的进程里执行的,同样正常退出的话,最好也给一个返回值

exit(0);

}

}

?>


这样一改好理解多了,如果你父进程希望知道子进程正常退出的话,可以加上前面的pcntl_wait.
函数的用法是整明白了,在实际的工作中有什么用处呢?
1.后台程序
命令行程序好写,服务程序也好写,笔者觉得这服务程序最难写.想想原来想在windows下写个服务啥的,又是要注册服务又是要这样那样的老费劲了.现在专职管理linux想让个命令行程序在后台运行,直接在命令后面加个&就搞定了.但是这样总觉得土.有了pcntl_fork突然发现世界是那么的美好.当主进程成功创建子进程并获得子进程的id以后,自己在临死前还不忘说一句:”我已成功运行,我的id是:xxxx(子进程的id)”,完了还给系统返回个0(正常退出),哈哈,死都死的那么有尊严.
前面说的是程序常驻内存的情况,当然了这时候要注意内存的释放以及向日志文件打印信息,而不是往屏幕上(一打印信息程序就退出的哟).还有一种情况是:程序被其它脚本调用,其它脚本只关心程序是不是正常运行,如果程序要运行很长时间才能运行完的话,最好不让脚本等待.这样的话pcntl_fork又派上用场了:)
2.延时处理.
有的时候,我们程序退出的时候要清理自身产生的东西,比如说要删除自己(当然了linux下面是可以删除正在运行的文件的,只是举个例子),这个时候就可以另起动一个进程,然后自己结束了,把事情交给另一个进程来做.当我们写服务程序的时候,我们肯定是写日志文件记录程序的运行情况(要不谁知道程序是不是在那睡大觉的:0).程序正常退出的时候我们可以写一条日志说程序退出了,但是当程序收到linux下伟大的kill -9的时候,怎么记录自己的退出行为呢?额…..这个和php的进程信号有关好像和这个没多大关系.
另一种情况:一个完善的程序一般都支持start,stop,restart这样的参数.start好说,stop也好说,既然start和stop都好说了,这个restart就先stop然后再start就可以了啊.额…好像又和pcntl_fork没多大关系,当你收到重启的信号总不能还是kill然后再start吧,是不是太黄太暴力了?还是温柔一点,让当前进程退出,让另外的进程再把它拉起来吧.在windows下想实现这一点似乎很困难呢,比如程序更新的时候,一般都是单写更新程序,或者程序退出的时候另起动一个批处理启动自己:)
3.不死进程
其实就是传说中的双进程了.早些年的时候万象网管为了达到不被恶意结束的目的用的就是这招了.虽然咱不用担心程序被人恶意停止,但是也保不齐主程序因为任务太重抗不住自己先挂了(这种情况也不是不会发生).所以……
说了这么多,只是对写程序的一些思考,对一个函数用法的延伸.我想到了这么多,你呢?
---
title: 6.5 标准 I/O 开发
author: admin
type: post
date: 2011-01-22T10:13:11+00:00
url: /archives/7577
IM_contentdowned:
 - 1
categories:
 - 程序开发
tags:
 - Linux

---
本章前面几节所述的文件及I/O 读写都是基于文件描述符的。这些都是基本的I/O 控制，是不带缓存的。而本节所要讨论的I/O 操作都是基于流缓冲的，它是符合ANSI C的标准I/O处理，这里有很多函数读者已经非常熟悉了（如printf、scantf 函数等），因此本节中仅简要介绍最主要的函数。

标准 I/O 提供流缓冲的目的是尽可能减少使用read和write调用的数量。标准I/O 提供了3 种类型的缓冲存储。

**· 全缓冲**。在这种情况下，当填满标准I/O 缓存后才进行实际I/O 操作。对于驻在磁盘上的文件通常是由标准I/O 库实施全缓冲的。在一个流上执行第一次I/O 操作时，通常调用malloc就是使用全缓冲。

**· 行缓冲**。在这种情况下，当在输入和输出中遇到新行符时，标准I/O 库执行I/O 操作。
这允许我们一次输出一个字符（如fputc 函数），但只有写了一行之后才进行实际I/O 操作。
当流涉及一个终端时（例如标准输入和标准输出），典型地使用行缓冲。

**· 不带缓冲**。标准I/O库不对字符进行缓冲。如果用标准I/O函数写若干字符到不带缓冲的流中，则相当于用write系统的用函数将这些字符写全相比较的打开文件上。标准出错况stderr通常是不带缓存后，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符。

在下面讨论具体函数时，请读者注意区分这3 种不同的情况。

**6.5.1 打开和关闭文件**

1．打开文件

（1）函数说明

打开文件有三个标准函数，分别为：fopen、fdopen 和freopen。它们可以以不同的模式打开，但都返回一个指向FILE 的指针，该指针以将对应的I/O 流相绑定了。此后，对文件的读写都是通过这个FILE 指针来进行。其中fopen 可以指定打开文件的路径和模式，fdopen可以指定打开的文件描述符和模式，而freopen 除可指定打开的文件、模式外，还可指定特定的IO 流。

（2）函数格式定义

fopen函数格式如表6.13 所示。表6.13 fopen 函数语法要点

所需头文件 **#include **

**函数原型** FILE * fopen(const char * path,const char * mode)

path：包含要打开的文件路径及文件名

**函数传入值**

mode：文件打开状态（后面会具体说明）

**函数返回值**

成功：指向FILE的指针

失败：NULL

这里的mode类似于open中的flag，可以定义打开文件的具体权限等，表6.14说明了fopen中mode的各种取值。

> 表6.14 mode取值说明
>
> r或rb 打开只读文件，该文件必须存在
>
> r＋或r＋b 打开可读写的文件，该文件必须存在
>
> w或wb 打开只写文件，若文件存在则文件长度清为0，即会擦些文件以前内容。若文件不存在则建立该文件
>
> w+或w＋b 打开可读写文件，若文件存在则文件长度清为0，即会擦些文件以前内容。若文件不存在则建立该文件
>
> a或ab 以附加的方式打开只写文件。若文件不存在，则会建立该文件；如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留
>
> a+或a＋b 以附加方式打开可读写的文件。若文件不存在，则会建立该文件；如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留
>
> 注意在每个选项中加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在Linux系统中会自动识别不同类型的文件而将此符号忽略。

fdopen函数格式如表6.15 所示。表6.15 fdopen 函数语法要点

所需头文件#**include **

**函数原型** FILE * fdopen(int fd,const char * mode)

fd：要打开的文件描述符

**函数传入值**

mode：文件打开状态（后面会具体说明）

**函数返回值**

成功：指向FILE的指针

失败：NULL

freopen函数格式如表6.16所示。表6.16 freopen 函数语法要点

所需头文件**#include **

**函数原型** FILE * freopen(const char *path,const char * mode,FILE * stream)

path：包含要打开的文件路径及文件名

**函数**